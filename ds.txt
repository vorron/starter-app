Контекст:
Мы разрабатываем эталонный Production Ready стартовый шаблон на Next.js 15, который будет основой для быстрого развертывания корпоративных приложений. В текущей реализации заложены модули profile и dashboard как примеры бизнес-логики, которые будут заменяться под конкретные задачи. Бэкенд — Nest.js с стандартной JWT-аутентификацией.

Ключевые принципы шаблона:

Архитектура FSD (Feature-Sliced Design)

Next.js 15 (App Router) с использованием современных подходов (React 19, RSC, Streaming)

Максимальный DX (Developer Experience): типобезопасность (строгий TSConfig, без any), линтеры, пре-коммит хуки

Производственная надежность: централизованная обработка ошибок, корректные состояния загрузки, безопасность

Задачи для анализа и рефакторинга:

Аудит архитектуры FSD:

Проверить соблюдение границ слоев (shared, entities, features, widgets, pages, app). Нет ли импортов "сверху вниз" (например, из features в entities)?

Проанализировать структуру src/shared: разделены ли UI киты, API-слой, утилиты и конфиги корректно? Нет ли слияния абстракций разного уровня?

Глубокая проверка системы обработки ошибок:

Проанализировать, является ли текущая реализация полностью типобезопасной на всех уровнях (от бэкенда до UI).

Проверить, различает ли система типы ошибок (сетевая ошибка, ошибка валидации 4xx, серверная 5xx, специфичная бизнес-логика) и предоставляет ли единый интерфейс для их обработки в UI (например, компонент ErrorBoundary).

Убедиться, что ошибки обрабатываются не только на уровне запросов (fetch/axios), но и на уровне рендеринга (React Error Boundaries для клиентских компонентов, error.js для серверных).

Аудит аутентификации и безопасности:

Проверить механизм хранения токена (httpOnly cookie vs localStorage). Соответствует ли выбранный способ лучшим практикам безопасности для Production?

Проанализировать обновление access token: реализован ли прозрачный механизм refresh token rotation? Нет ли race condition при параллельных запросах.

Проверить защиту маршрутов: реализована ли она единообразно на уровне middleware и внутри компонентов/страниц?

Оптимизация и "здоровье" кода:

Выявить и удалить весь "мертвый" код.

Найти и удалить комментарии, которые не несут ценности (например, поясняющие очевидные вещи), оставив только те, что объясняют "почему", а не "что".

Проверить, все ли динамические импорты (lazy) оправданы и обернуты в Suspense с адекватными fallback.

Анализ данных и запросов:

Проверить, используется ли современный подход к кэшированию и инвалидации данных. Нет ли избыточных или неоптимальных ручных реализаций.

Соответствует ли структура API-слоя (клиент для бэкенда) принципам инкапсуляции и легкости модификации.

Критерии приемки:

Запрещено вносить изменения, которые не имеют прямого отношения к заявленным принципам (No regression).

Любое изменение должно быть обосновано с точки зрения Production-опыта (например, "это добавляем, потому что в 90% приложений придется это делать").

Код после рефакторинга должен оставаться лаконичным. Не предлагать избыточные абстракции "на будущее".

Предлагать исправления в виде конкретного кода, а не общих рекомендаций.

Итоговый результат: Полностью готовый к работе эталонный шаблон, в котором исправлены системные недочеты, а код соответствует современным best practices для коммерческой разработки.

Так же обрати внимание на реализацию кода в папке shared/lib/query-client все ли там по лучшим практикам и современным тенденциям
